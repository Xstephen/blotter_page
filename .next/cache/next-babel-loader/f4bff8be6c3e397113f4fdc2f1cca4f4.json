{"ast":null,"code":"module.exports = function wasm() {\n  // Copyright 2018 The Go Authors. All rights reserved.\n  // Use of this source code is governed by a BSD-style\n  // license that can be found in the LICENSE file.\n  // Map multiple JavaScript environments to a single common API,\n  // preferring web standards over Node.js API.\n  //\n  // Environments considered:\n  // - Browsers\n  // - Node.js\n  // - Electron\n  // - Parcel\n  if (typeof global !== 'undefined') {// global already exists\n  } else if (false) {\n    window.global = window;\n  } else if (typeof self !== 'undefined') {\n    self.global = self;\n  } else {\n    throw new Error('cannot export Go (neither global, window nor self is defined)');\n  }\n\n  if (!global.require && typeof require !== 'undefined') {\n    global.require = require;\n  } //   if (!global.fs && global.require) {\n  //     global.fs = require('fs');\n  //   }\n\n\n  const enosys = () => {\n    const err = new Error('not implemented');\n    err.code = 'ENOSYS';\n    return err;\n  };\n\n  if (!global.fs) {\n    let outputBuf = '';\n    global.fs = {\n      constants: {\n        O_WRONLY: -1,\n        O_RDWR: -1,\n        O_CREAT: -1,\n        O_TRUNC: -1,\n        O_APPEND: -1,\n        O_EXCL: -1\n      },\n\n      // unused\n      writeSync(fd, buf) {\n        outputBuf += decoder.decode(buf);\n        const nl = outputBuf.lastIndexOf('\\n');\n\n        if (nl != -1) {\n          console.log(outputBuf.substr(0, nl));\n          outputBuf = outputBuf.substr(nl + 1);\n        }\n\n        return buf.length;\n      },\n\n      write(fd, buf, offset, length, position, callback) {\n        if (offset !== 0 || length !== buf.length || position !== null) {\n          callback(enosys());\n          return;\n        }\n\n        const n = this.writeSync(fd, buf);\n        callback(null, n);\n      },\n\n      chmod(path, mode, callback) {\n        callback(enosys());\n      },\n\n      chown(path, uid, gid, callback) {\n        callback(enosys());\n      },\n\n      close(fd, callback) {\n        callback(enosys());\n      },\n\n      fchmod(fd, mode, callback) {\n        callback(enosys());\n      },\n\n      fchown(fd, uid, gid, callback) {\n        callback(enosys());\n      },\n\n      fstat(fd, callback) {\n        callback(enosys());\n      },\n\n      fsync(fd, callback) {\n        callback(null);\n      },\n\n      ftruncate(fd, length, callback) {\n        callback(enosys());\n      },\n\n      lchown(path, uid, gid, callback) {\n        callback(enosys());\n      },\n\n      link(path, link, callback) {\n        callback(enosys());\n      },\n\n      lstat(path, callback) {\n        callback(enosys());\n      },\n\n      mkdir(path, perm, callback) {\n        callback(enosys());\n      },\n\n      open(path, flags, mode, callback) {\n        callback(enosys());\n      },\n\n      read(fd, buffer, offset, length, position, callback) {\n        callback(enosys());\n      },\n\n      readdir(path, callback) {\n        callback(enosys());\n      },\n\n      readlink(path, callback) {\n        callback(enosys());\n      },\n\n      rename(from, to, callback) {\n        callback(enosys());\n      },\n\n      rmdir(path, callback) {\n        callback(enosys());\n      },\n\n      stat(path, callback) {\n        callback(enosys());\n      },\n\n      symlink(path, link, callback) {\n        callback(enosys());\n      },\n\n      truncate(path, length, callback) {\n        callback(enosys());\n      },\n\n      unlink(path, callback) {\n        callback(enosys());\n      },\n\n      utimes(path, atime, mtime, callback) {\n        callback(enosys());\n      }\n\n    };\n  }\n\n  if (!global.process) {\n    global.process = {\n      getuid() {\n        return -1;\n      },\n\n      getgid() {\n        return -1;\n      },\n\n      geteuid() {\n        return -1;\n      },\n\n      getegid() {\n        return -1;\n      },\n\n      getgroups() {\n        throw enosys();\n      },\n\n      pid: -1,\n      ppid: -1,\n\n      umask() {\n        throw enosys();\n      },\n\n      cwd() {\n        throw enosys();\n      },\n\n      chdir() {\n        throw enosys();\n      }\n\n    };\n  }\n\n  if (!global.crypto) {\n    const nodeCrypto = require('crypto');\n\n    global.crypto = {\n      getRandomValues(b) {\n        nodeCrypto.randomFillSync(b);\n      }\n\n    };\n  }\n\n  if (!global.performance) {\n    global.performance = {\n      now() {\n        const [sec, nsec] = process.hrtime();\n        return sec * 1000 + nsec / 1000000;\n      }\n\n    };\n  }\n\n  if (!global.TextEncoder) {\n    global.TextEncoder = require('util').TextEncoder;\n  }\n\n  if (!global.TextDecoder) {\n    global.TextDecoder = require('util').TextDecoder;\n  } // End of polyfills for common API.\n\n\n  const encoder = new TextEncoder('utf-8');\n  const decoder = new TextDecoder('utf-8');\n  global.Go = class {\n    constructor() {\n      this.argv = ['js'];\n      this.env = {};\n\n      this.exit = code => {\n        if (code !== 0) {\n          console.warn('exit code:', code);\n        }\n      };\n\n      this._exitPromise = new Promise(resolve => {\n        this._resolveExitPromise = resolve;\n      });\n      this._pendingEvent = null;\n      this._scheduledTimeouts = new Map();\n      this._nextCallbackTimeoutID = 1;\n\n      const setInt64 = (addr, v) => {\n        this.mem.setUint32(addr + 0, v, true);\n        this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n      };\n\n      const getInt64 = addr => {\n        const low = this.mem.getUint32(addr + 0, true);\n        const high = this.mem.getInt32(addr + 4, true);\n        return low + high * 4294967296;\n      };\n\n      const loadValue = addr => {\n        const f = this.mem.getFloat64(addr, true);\n\n        if (f === 0) {\n          return undefined;\n        }\n\n        if (!isNaN(f)) {\n          return f;\n        }\n\n        const id = this.mem.getUint32(addr, true);\n        return this._values[id];\n      };\n\n      const storeValue = (addr, v) => {\n        const nanHead = 0x7ff80000;\n\n        if (typeof v === 'number') {\n          if (isNaN(v)) {\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 0, true);\n            return;\n          }\n\n          if (v === 0) {\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 1, true);\n            return;\n          }\n\n          this.mem.setFloat64(addr, v, true);\n          return;\n        }\n\n        switch (v) {\n          case undefined:\n            this.mem.setFloat64(addr, 0, true);\n            return;\n\n          case null:\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 2, true);\n            return;\n\n          case true:\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 3, true);\n            return;\n\n          case false:\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 4, true);\n            return;\n        }\n\n        let id = this._ids.get(v);\n\n        if (id === undefined) {\n          id = this._idPool.pop();\n\n          if (id === undefined) {\n            id = this._values.length;\n          }\n\n          this._values[id] = v;\n          this._goRefCounts[id] = 0;\n\n          this._ids.set(v, id);\n        }\n\n        this._goRefCounts[id]++;\n        let typeFlag = 1;\n\n        switch (typeof v) {\n          case 'string':\n            typeFlag = 2;\n            break;\n\n          case 'symbol':\n            typeFlag = 3;\n            break;\n\n          case 'function':\n            typeFlag = 4;\n            break;\n        }\n\n        this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n        this.mem.setUint32(addr, id, true);\n      };\n\n      const loadSlice = addr => {\n        const array = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n      };\n\n      const loadSliceOfValues = addr => {\n        const array = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        const a = new Array(len);\n\n        for (let i = 0; i < len; i++) {\n          a[i] = loadValue(array + i * 8);\n        }\n\n        return a;\n      };\n\n      const loadString = addr => {\n        const saddr = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n      };\n\n      const timeOrigin = Date.now() - performance.now();\n      this.importObject = {\n        go: {\n          // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n          // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n          // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n          // This changes the SP, thus we have to update the SP used by the imported function.\n          // func wasmExit(code int32)\n          'runtime.wasmExit': sp => {\n            const code = this.mem.getInt32(sp + 8, true);\n            this.exited = true;\n            delete this._inst;\n            delete this._values;\n            delete this._goRefCounts;\n            delete this._ids;\n            delete this._idPool;\n            this.exit(code);\n          },\n          // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n          'runtime.wasmWrite': sp => {\n            const fd = getInt64(sp + 8);\n            const p = getInt64(sp + 16);\n            const n = this.mem.getInt32(sp + 24, true);\n            fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n          },\n          // func resetMemoryDataView()\n          'runtime.resetMemoryDataView': sp => {\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n          },\n          // func nanotime1() int64\n          'runtime.nanotime1': sp => {\n            setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n          },\n          // func walltime1() (sec int64, nsec int32)\n          'runtime.walltime1': sp => {\n            const msec = new Date().getTime();\n            setInt64(sp + 8, msec / 1000);\n            this.mem.setInt32(sp + 16, msec % 1000 * 1000000, true);\n          },\n          // func scheduleTimeoutEvent(delay int64) int32\n          'runtime.scheduleTimeoutEvent': sp => {\n            const id = this._nextCallbackTimeoutID;\n            this._nextCallbackTimeoutID++;\n\n            this._scheduledTimeouts.set(id, setTimeout(() => {\n              this._resume();\n\n              while (this._scheduledTimeouts.has(id)) {\n                // for some reason Go failed to register the timeout event, log and try again\n                // (temporary workaround for https://github.com/golang/go/issues/28975)\n                console.warn('scheduleTimeoutEvent: missed timeout event');\n\n                this._resume();\n              }\n            }, getInt64(sp + 8) + 1 // setTimeout has been seen to fire up to 1 millisecond early\n            ));\n\n            this.mem.setInt32(sp + 16, id, true);\n          },\n          // func clearTimeoutEvent(id int32)\n          'runtime.clearTimeoutEvent': sp => {\n            const id = this.mem.getInt32(sp + 8, true);\n            clearTimeout(this._scheduledTimeouts.get(id));\n\n            this._scheduledTimeouts.delete(id);\n          },\n          // func getRandomData(r []byte)\n          'runtime.getRandomData': sp => {\n            crypto.getRandomValues(loadSlice(sp + 8));\n          },\n          // func finalizeRef(v ref)\n          'syscall/js.finalizeRef': sp => {\n            const id = this.mem.getUint32(sp + 8, true);\n            this._goRefCounts[id]--;\n\n            if (this._goRefCounts[id] === 0) {\n              const v = this._values[id];\n              this._values[id] = null;\n\n              this._ids.delete(v);\n\n              this._idPool.push(id);\n            }\n          },\n          // func stringVal(value string) ref\n          'syscall/js.stringVal': sp => {\n            storeValue(sp + 24, loadString(sp + 8));\n          },\n          // func valueGet(v ref, p string) ref\n          'syscall/js.valueGet': sp => {\n            const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n            sp = this._inst.exports.getsp(); // see comment above\n\n            storeValue(sp + 32, result);\n          },\n          // func valueSet(v ref, p string, x ref)\n          'syscall/js.valueSet': sp => {\n            Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n          },\n          // func valueDelete(v ref, p string)\n          'syscall/js.valueDelete': sp => {\n            Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n          },\n          // func valueIndex(v ref, i int) ref\n          'syscall/js.valueIndex': sp => {\n            storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n          },\n          // valueSetIndex(v ref, i int, x ref)\n          'syscall/js.valueSetIndex': sp => {\n            Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n          },\n          // func valueCall(v ref, m string, args []ref) (ref, bool)\n          'syscall/js.valueCall': sp => {\n            try {\n              const v = loadValue(sp + 8);\n              const m = Reflect.get(v, loadString(sp + 16));\n              const args = loadSliceOfValues(sp + 32);\n              const result = Reflect.apply(m, v, args);\n              sp = this._inst.exports.getsp(); // see comment above\n\n              storeValue(sp + 56, result);\n              this.mem.setUint8(sp + 64, 1);\n            } catch (err) {\n              storeValue(sp + 56, err);\n              this.mem.setUint8(sp + 64, 0);\n            }\n          },\n          // func valueInvoke(v ref, args []ref) (ref, bool)\n          'syscall/js.valueInvoke': sp => {\n            try {\n              const v = loadValue(sp + 8);\n              const args = loadSliceOfValues(sp + 16);\n              const result = Reflect.apply(v, undefined, args);\n              sp = this._inst.exports.getsp(); // see comment above\n\n              storeValue(sp + 40, result);\n              this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              storeValue(sp + 40, err);\n              this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueNew(v ref, args []ref) (ref, bool)\n          'syscall/js.valueNew': sp => {\n            try {\n              const v = loadValue(sp + 8);\n              const args = loadSliceOfValues(sp + 16);\n              const result = Reflect.construct(v, args);\n              sp = this._inst.exports.getsp(); // see comment above\n\n              storeValue(sp + 40, result);\n              this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              storeValue(sp + 40, err);\n              this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueLength(v ref) int\n          'syscall/js.valueLength': sp => {\n            setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n          },\n          // valuePrepareString(v ref) (ref, int)\n          'syscall/js.valuePrepareString': sp => {\n            const str = encoder.encode(String(loadValue(sp + 8)));\n            storeValue(sp + 16, str);\n            setInt64(sp + 24, str.length);\n          },\n          // valueLoadString(v ref, b []byte)\n          'syscall/js.valueLoadString': sp => {\n            const str = loadValue(sp + 8);\n            loadSlice(sp + 16).set(str);\n          },\n          // func valueInstanceOf(v ref, t ref) bool\n          'syscall/js.valueInstanceOf': sp => {\n            this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16));\n          },\n          // func copyBytesToGo(dst []byte, src ref) (int, bool)\n          'syscall/js.copyBytesToGo': sp => {\n            const dst = loadSlice(sp + 8);\n            const src = loadValue(sp + 32);\n\n            if (!(src instanceof Uint8Array)) {\n              this.mem.setUint8(sp + 48, 0);\n              return;\n            }\n\n            const toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n            this.mem.setUint8(sp + 48, 1);\n          },\n          // func copyBytesToJS(dst ref, src []byte) (int, bool)\n          'syscall/js.copyBytesToJS': sp => {\n            const dst = loadValue(sp + 8);\n            const src = loadSlice(sp + 16);\n\n            if (!(dst instanceof Uint8Array)) {\n              this.mem.setUint8(sp + 48, 0);\n              return;\n            }\n\n            const toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n            this.mem.setUint8(sp + 48, 1);\n          },\n          debug: value => {\n            console.log(value);\n          }\n        }\n      };\n    }\n\n    async run(instance) {\n      this._inst = instance;\n      this.mem = new DataView(this._inst.exports.mem.buffer);\n      this._values = [// JS values that Go currently has references to, indexed by reference id\n      NaN, 0, null, true, false, global, this];\n      this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n\n      this._ids = new Map(); // mapping from JS values to reference ids\n\n      this._idPool = []; // unused ids that have been garbage collected\n\n      this.exited = false; // whether the Go program has exited\n      // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\n      let offset = 4096;\n\n      const strPtr = str => {\n        const ptr = offset;\n        const bytes = encoder.encode(str + '\\0');\n        new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n        offset += bytes.length;\n\n        if (offset % 8 !== 0) {\n          offset += 8 - offset % 8;\n        }\n\n        return ptr;\n      };\n\n      const argc = this.argv.length;\n      const argvPtrs = [];\n      this.argv.forEach(arg => {\n        argvPtrs.push(strPtr(arg));\n      });\n      argvPtrs.push(0);\n      const keys = Object.keys(this.env).sort();\n      keys.forEach(key => {\n        argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n      });\n      argvPtrs.push(0);\n      const argv = offset;\n      argvPtrs.forEach(ptr => {\n        this.mem.setUint32(offset, ptr, true);\n        this.mem.setUint32(offset + 4, 0, true);\n        offset += 8;\n      });\n\n      this._inst.exports.run(argc, argv);\n\n      if (this.exited) {\n        this._resolveExitPromise();\n      }\n\n      await this._exitPromise;\n    }\n\n    _resume() {\n      if (this.exited) {\n        throw new Error('Go program has already exited');\n      }\n\n      this._inst.exports.resume();\n\n      if (this.exited) {\n        this._resolveExitPromise();\n      }\n    }\n\n    _makeFuncWrapper(id) {\n      const go = this;\n      return function () {\n        const event = {\n          id: id,\n          this: this,\n          args: arguments\n        };\n        go._pendingEvent = event;\n\n        go._resume();\n\n        return event.result;\n      };\n    }\n\n  };\n\n  if (global.require && global.require.main === module && global.process && global.process.versions && !global.process.versions.electron) {\n    if (process.argv.length < 3) {\n      console.error('usage: go_js_wasm_exec [wasm binary] [arguments]');\n      process.exit(1);\n    }\n\n    const go = new Go();\n    go.argv = process.argv.slice(2);\n    go.env = Object.assign({\n      TMPDIR: require('os').tmpdir()\n    }, process.env);\n    go.exit = process.exit;\n    WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then(result => {\n      process.on('exit', code => {\n        // Node.js exits if no event handler is pending\n        if (code === 0 && !go.exited) {\n          // deadlock, make Go print error and stack traces\n          go._pendingEvent = {\n            id: 0\n          };\n\n          go._resume();\n        }\n      });\n      return go.run(result.instance);\n    }).catch(err => {\n      console.error(err);\n      process.exit(1);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}