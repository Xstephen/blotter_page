{"ast":null,"code":"import \"antd/lib/tabs/style/css\";\nimport _Tabs from \"antd/lib/tabs\";\nimport \"antd/lib/card/style/css\";\nimport _Card from \"antd/lib/card\";\nimport \"antd/lib/typography/style/css\";\nimport _Typography from \"antd/lib/typography\";\nimport \"antd/lib/popconfirm/style/css\";\nimport _Popconfirm from \"antd/lib/popconfirm\";\nimport \"antd/lib/upload/style/css\";\nimport _Upload from \"antd/lib/upload\";\nimport \"antd/lib/notification/style/css\";\nimport _notification from \"antd/lib/notification\";\nimport \"antd/lib/button/style/css\";\nimport _Button from \"antd/lib/button\";\nimport \"antd/lib/select/style/css\";\nimport _Select from \"antd/lib/select\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport { SyncOutlined, SaveOutlined, DeleteOutlined } from '@ant-design/icons';\nimport * as qiniu from 'qiniu-js';\nimport { Space } from '@/components/container';\nimport Image from '@/components/image';\nimport { qiniu_get_buckets, qiniu_get_images, qiniu_get_token, qiniu_delete_image, qiniu_rename_image } from '@/utils/api';\nimport { waitUntil } from '@/utils/debounce';\nimport ShowNotification from '@/utils/notification';\nimport styles from './upload.less';\nconst img_file_type = ['psd', 'jpg', 'jpeg', 'png', 'gif', 'webp', 'tiff', 'bmp'];\n\nfunction generateThumbnail(img) {\n  if (img_file_type.indexOf(img.split('.').slice(-1)[0]) != -1) return `${img}?imageView2/0/w/128/h/128/interlace/1/q/50`;else img;\n}\n\nfunction BucketSelector(props) {\n  const {\n    bucket,\n    prefix,\n    onChange = () => {},\n    imgRef\n  } = props;\n  const [prefixList, setPrefixList] = React.useState([]);\n  const [loading, setLoading] = React.useState(false);\n  const [buckets, setBuckets] = React.useState([]);\n\n  function initial() {\n    setLoading(true);\n    qiniu_get_buckets().then(r => {\n      setBuckets(r.buckets);\n      setPrefixList(Array.from(new Set([''].concat(r.prefix))));\n      if (bucket == '' && r.buckets.length != 0) onChange(r.buckets[0], '');\n    }).catch(console.error).finally(() => setLoading(false));\n  }\n\n  React.useEffect(initial, []);\n  return __jsx(Space, {\n    direction: \"horizontal\"\n  }, __jsx(\"strong\", null, \"\\u5B58\\u50A8\\u7A7A\\u95F4\\uFF1A\"), __jsx(_Select, {\n    value: bucket,\n    onChange: b => onChange(b, prefix),\n    loading: loading\n  }, buckets.map(b => __jsx(_Select.Option, {\n    key: b,\n    value: b\n  }, b))), __jsx(_Button, {\n    onClick: initial,\n    icon: __jsx(SyncOutlined, {\n      spin: loading\n    })\n  }), __jsx(_Select, {\n    style: {\n      minWidth: 100\n    },\n    value: prefix,\n    onChange: p => onChange(bucket, p),\n    showSearch: true,\n    clearIcon: true,\n    onSearch: p => {\n      waitUntil('image_prefix', () => {\n        if (p !== '') onChange(bucket, p);\n      }, 500);\n    },\n    loading: loading,\n    notFoundContent: null\n  }, prefixList.map(p => __jsx(_Select.Option, {\n    key: p,\n    value: p\n  }, p))), __jsx(_Button, {\n    onClick: () => {\n      if (!!imgRef && !!imgRef.current) imgRef.current.refresh();\n    }\n  }, \"\\u5237\\u65B0\\u56FE\\u7247\"));\n}\n\nfunction Upload(props) {\n  const {\n    bucket,\n    prefix\n  } = props;\n\n  const upload = async file => {\n    const token = (await qiniu_get_token()).token;\n    const filename = !!prefix ? `${prefix}/${file.name}` : file.name;\n    const observable = qiniu.upload(file, filename, token, {}, {});\n    const subscription = observable.subscribe({\n      next(res) {\n        console.log(res);\n      },\n\n      error(err) {\n        _notification.error({\n          message: `${filename} 上传发生错误`,\n          description: `${err}`\n        });\n\n        console.error(err);\n      },\n\n      complete(res) {\n        _notification.success({\n          message: `${filename} 上传成功`\n        });\n      }\n\n    });\n  };\n\n  return __jsx(_Upload.Dragger, {\n    name: 'file',\n    multiple: true,\n    customRequest: opts => upload(opts.file),\n    showUploadList: false\n  }, __jsx(\"div\", {\n    style: {\n      height: 100,\n      width: '100%'\n    }\n  }, __jsx(\"p\", null, \"\\u5C06\\u6587\\u4EF6\\u62D6\\u62FD\\u5230\\u6B64\\u5904\\u4E0A\\u4F20\")));\n}\n\nconst ImageList = React.forwardRef(imageList);\n\nfunction imageList(props, ref) {\n  // props\n  const {\n    bucket,\n    prefix,\n    group_number = 10\n  } = props; // state\n\n  const [marker, setMarker] = React.useState('');\n  const [hasNext, setHasNext] = React.useState(false);\n  const [loading, setLoading] = React.useState(false);\n  const [images, setImages] = React.useReducer((images, action) => {\n    const {\n      method\n    } = action;\n\n    switch (method) {\n      case 'initial':\n        {\n          const {\n            value = []\n          } = action;\n          return value.map(img => _objectSpread(_objectSpread({}, img), {}, {\n            new_key: img.key\n          }));\n        }\n\n      case 'concat':\n        {\n          const {\n            value = []\n          } = action;\n          return images.concat(value.map(img => _objectSpread(_objectSpread({}, img), {}, {\n            new_key: img.key\n          })));\n        }\n\n      case 'update':\n        {\n          const {\n            index = 0,\n            key = images[index].new_key\n          } = action;\n          return [...images.slice(0, index), _objectSpread(_objectSpread({}, images[index]), {}, {\n            new_key: key\n          }), ...images.slice(index + 1)];\n        }\n\n      default:\n        {\n          throw new Error();\n        }\n    }\n  }, []); // ref\n\n  const [id, setID] = React.useState(0);\n  const idRef = React.useRef(id);\n  idRef.current = id;\n  const getData = React.useCallback((b, p, m) => {\n    setLoading(true);\n    var thisID = id + 1;\n    setID(thisID); // setID((i) => (idRef.current = thisID = i + 1));\n\n    qiniu_get_images(b, p, m, group_number).then(r => {\n      if (idRef.current === thisID) {\n        setImages({\n          method: !!m ? 'concat' : 'initial',\n          value: r.files\n        });\n        setMarker(r.marker), setHasNext(r.has_next);\n      }\n    }).catch(console.error).finally(() => setLoading(false));\n  }, [id, group_number]);\n  const initial = React.useCallback(() => getData(bucket, prefix, ''), [bucket, prefix]);\n  React.useImperativeHandle(ref, () => ({\n    refresh: initial\n  }), [bucket, prefix]); // init data\n\n  React.useEffect(() => {\n    setImages({\n      method: 'initial'\n    }), setMarker(''), setHasNext(false);\n    initial();\n  }, [bucket, prefix]);\n  return __jsx(\"div\", {\n    className: styles.wrapper\n  }, __jsx(\"div\", {\n    className: styles.inner\n  }, images.map((image, idx) => {\n    return __jsx(_Card, {\n      key: image.new_key,\n      className: styles.card,\n      size: \"small\",\n      cover: __jsx(Image, {\n        src: image.link,\n        thumbnail: generateThumbnail(image.link),\n        height: \"128px\",\n        width: \"128px\",\n        clickable: true\n      }),\n      actions: [__jsx(SaveOutlined, {\n        onClick: async () => {\n          if (ShowNotification(await qiniu_rename_image(bucket, image.key, image.new_key))) initial();\n        }\n      }), __jsx(_Popconfirm, {\n        title: \"\\u786E\\u5B9A\\u5220\\u9664\\uFF1F\",\n        onConfirm: async () => {\n          if (ShowNotification(await qiniu_delete_image(bucket, image.key))) initial();\n        }\n      }, __jsx(DeleteOutlined, {\n        style: {\n          color: 'red'\n        }\n      }))]\n    }, __jsx(_Typography.Text, {\n      ellipsis: true,\n      copyable: {\n        text: image.link\n      },\n      editable: {\n        onChange: v => {\n          setImages({\n            method: 'update',\n            index: idx,\n            key: v\n          });\n        }\n      }\n    }, image.new_key));\n  })), __jsx(_Button, {\n    onClick: () => getData(bucket, prefix, marker),\n    disabled: !hasNext,\n    loading: loading\n  }, \"\\u83B7\\u53D6\\u66F4\\u591A\"));\n}\n\nfunction Qiniu(props) {\n  const {\n    defaultTab = 'upload',\n    group_number = 10\n  } = props;\n  const [bucket, setBucket] = React.useState('');\n  const [prefix, setPrefix] = React.useState('');\n  const ref = React.useRef();\n  const setState = React.useCallback((b, p) => {\n    if (b !== bucket) setBucket(b);\n    if (p !== prefix) setPrefix(p);\n  }, [bucket, prefix]);\n  return __jsx(Space, {\n    direction: \"vertical\"\n  }, __jsx(BucketSelector, {\n    bucket: bucket,\n    prefix: prefix,\n    onChange: setState,\n    imgRef: ref\n  }), __jsx(_Tabs, {\n    defaultValue: defaultTab,\n    tabPosition: \"left\"\n  }, __jsx(_Tabs.TabPane, {\n    tab: \"\\u4E0A\\u4F20\\u56FE\\u7247\",\n    key: \"upload\"\n  }, __jsx(Upload, {\n    bucket: bucket,\n    prefix: prefix\n  })), __jsx(_Tabs.TabPane, {\n    tab: \"\\u56FE\\u7247\\u5217\\u8868\",\n    key: \"list\"\n  }, __jsx(ImageList, {\n    ref: ref,\n    bucket: bucket,\n    prefix: prefix,\n    group_number: group_number\n  }))));\n}\n\nexport default Qiniu;\nexport { BucketSelector, Upload, ImageList };","map":null,"metadata":{},"sourceType":"module"}